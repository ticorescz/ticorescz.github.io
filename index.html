<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ticore | Catalogo</title>
  <link rel="icon" href="images/logo.svg" type="image/svg+xml">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
</head>
<body class="swipe-hub">
  <div data-include="header.html"></div>
  <main class="swipe-container">
    <div class="swipe-stage" role="region" aria-label="Catalogo deslizable">
      <div class="swipe-track" id="swipe-track">
        <section class="swipe-panel" data-src="catalog.html" aria-label="Inicio">
          <iframe title="Inicio" loading="lazy"></iframe>
          <div class="panel-loading">Cargando Inicio...</div>
        </section>
        <section class="swipe-panel" data-src="hombre.html" aria-label="Hombre">
          <iframe title="Hombre" loading="lazy"></iframe>
          <div class="panel-loading">Cargando Hombre...</div>
        </section>
        <section class="swipe-panel" data-src="mujer.html" aria-label="Mujer">
          <iframe title="Mujer" loading="lazy"></iframe>
          <div class="panel-loading">Cargando Mujer...</div>
        </section>
      </div>
      <div class="swipe-progress" aria-hidden="true">
        <span class="is-active"></span>
        <span></span>
        <span></span>
      </div>
    </div>
  </main>
  <div data-include="catalog-nav.html"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const stage = document.querySelector('.swipe-stage');
      const track = document.getElementById('swipe-track');
      if (!stage || !track) return;

      const panels = Array.from(track.querySelectorAll('.swipe-panel'));
      const dots = Array.from(document.querySelectorAll('.swipe-progress span'));
      const panelPaths = panels.map(panel => normalizePath(panel.dataset.src));
      const dragState = { active: false, pending: false, startX: 0, startY: 0, prevTranslate: 0, currentTranslate: 0, pointerId: null };
      let navController = null;
      let headerLinks = [];
      let currentIndex = 0;
      const pointerShouldHandle = (event) => !event.pointerType || event.pointerType !== 'touch';
      const horizontalDeadZone = 32;
      const verticalAbortThreshold = 18;

      function normalizePath(href) {
        try {
          const url = new URL(href, window.location.href);
          let path = url.pathname.replace(/\/+/g, '/');
          if (!path.startsWith('/')) path = `/${path}`;
          if (path === '/' || path === '') path = '/index.html';
          if (path.endsWith('/')) path = `${path}index.html`;
          return path;
        } catch (error) {
          return href;
        }
      }

      const stageWidth = () => stage.getBoundingClientRect().width;
      const applyTranslate = (value) => track.style.transform = `translateX(${value}px)`;

      const updateDots = () => {
        dots.forEach((dot, idx) => dot.classList.toggle('is-active', idx === currentIndex));
      };

      const setHomeChrome = (isHome) => {
        document.body.classList.toggle('is-home-panel', isHome);
      };

      const loadPanel = (index) => {
        const panel = panels[index];
        if (!panel) return;
        const iframe = panel.querySelector('iframe');
        if (!iframe || iframe.dataset.loaded === 'true') return;
        iframe.src = panel.dataset.src;
        iframe.dataset.loaded = 'true';
        iframe.addEventListener('load', () => {
          panel.querySelector('.panel-loading')?.remove();
          bindFrameGestures(iframe);
        }, { once: true });
      };

      const syncHeaderLinks = (href) => {
        if (!headerLinks.length) return;
        const normalized = normalizePath(href);
        headerLinks.forEach(link => {
          const match = normalizePath(link.getAttribute('href')) === normalized;
          link.classList.toggle('is-active', match);
          if (match) {
            link.setAttribute('aria-current', 'page');
          } else {
            link.removeAttribute('aria-current');
          }
        });
      };

      const snapToIndex = (instant = false) => {
        const target = -currentIndex * stageWidth();
        if (instant) {
          track.classList.add('is-dragging');
          applyTranslate(target);
          requestAnimationFrame(() => track.classList.remove('is-dragging'));
        } else {
          applyTranslate(target);
        }
        dragState.prevTranslate = target;
        dragState.currentTranslate = target;
      };

      const updateActive = (index) => {
        currentIndex = Math.max(0, Math.min(index, panels.length - 1));
        snapToIndex();
        updateDots();
        loadPanel(currentIndex);
        loadPanel(currentIndex + 1);
        loadPanel(currentIndex - 1);
        const activeSrc = panels[currentIndex]?.dataset.src;
        navController?.setActiveByHref(activeSrc);
        syncHeaderLinks(activeSrc);
        setHomeChrome(currentIndex === 0);
      };

      const handleSwipe = (direction) => {
        if (direction === 'next') {
          updateActive(currentIndex + 1);
        } else if (direction === 'prev') {
          updateActive(currentIndex - 1);
        }
      };

      const findIndexByHref = (href) => panelPaths.indexOf(normalizePath(href));

      const goToHref = (href) => {
        const idx = findIndexByHref(href);
        if (idx >= 0) {
          updateActive(idx);
          return true;
        }
        return false;
      };

      window.catalogShellNavigate = (href) => {
        if (!href) return false;
        return goToHref(href);
      };

      const startDrag = (x, y = 0, pointerId = null, immediate = false) => {
        if (dragState.active || dragState.pending) return;
        dragState.pointerId = pointerId;
        dragState.startX = x;
        dragState.startY = y;
        dragState.prevTranslate = -currentIndex * stageWidth();
        dragState.currentTranslate = dragState.prevTranslate;
        dragState.pending = !immediate;
        dragState.active = immediate;
        if (immediate) {
          track.classList.add('is-dragging');
        }
      };

      const cancelPendingDrag = () => {
        dragState.pending = false;
        dragState.pointerId = null;
      };

      const activateDrag = () => {
        if (dragState.active) return;
        dragState.active = true;
        dragState.pending = false;
        track.classList.add('is-dragging');
      };

      const moveDrag = (x, y = null, pointerId = null) => {
        if (!dragState.active && !dragState.pending) return;
        if (dragState.pointerId !== null && pointerId !== null && pointerId !== dragState.pointerId) return;

        if (dragState.pending) {
          if (y === null) {
            activateDrag();
          } else {
            const deltaX = x - dragState.startX;
            const deltaY = y - dragState.startY;
            if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > verticalAbortThreshold) {
              cancelPendingDrag();
              return;
            }
            if (Math.abs(deltaX) >= horizontalDeadZone) {
              activateDrag();
            } else {
              return;
            }
          }
        }

        if (!dragState.active) return;
        dragState.currentTranslate = dragState.prevTranslate + (x - dragState.startX);
        applyTranslate(dragState.currentTranslate);
      };

      const endDrag = (pointerId = null) => {
        if (!dragState.active && !dragState.pending) return;
        if (dragState.pointerId !== null && pointerId !== null && pointerId !== dragState.pointerId) return;

        if (dragState.pending && !dragState.active) {
          cancelPendingDrag();
          return;
        }

        dragState.active = false;
        dragState.pending = false;
        dragState.pointerId = null;
        track.classList.remove('is-dragging');
        const moved = dragState.currentTranslate - dragState.prevTranslate;
        const snapThreshold = Math.min(stageWidth() * 0.18, 260);
        if (Math.abs(moved) > snapThreshold) {
          handleSwipe(moved < 0 ? 'next' : 'prev');
        } else {
          snapToIndex();
        }
      };

      const bindFrameGestures = (iframe) => {
        if (!iframe || iframe.dataset.gestureReady === 'true') return;
        iframe.dataset.gestureReady = 'true';
        try {
          const doc = iframe.contentWindow?.document;
          if (!doc) return;
          doc.addEventListener('touchstart', (event) => {
            if (event.touches.length !== 1) return;
            const touch = event.touches[0];
            startDrag(touch.clientX, touch.clientY);
          }, { passive: true });
          doc.addEventListener('touchmove', (event) => {
            if (event.touches.length !== 1) return;
            const touch = event.touches[0];
            moveDrag(touch.clientX, touch.clientY);
          }, { passive: true });
          doc.addEventListener('touchend', endDrag);
          doc.addEventListener('touchcancel', endDrag);
          doc.addEventListener('pointerdown', (event) => {
            if (!pointerShouldHandle(event) || event.button !== 0) return;
            startDrag(event.clientX, event.clientY, event.pointerId, true);
          });
          doc.addEventListener('pointermove', (event) => {
            if (!pointerShouldHandle(event)) return;
            if (event.buttons === 0) return;
            moveDrag(event.clientX, event.clientY, event.pointerId);
          });
          doc.addEventListener('pointerup', (event) => {
            if (!pointerShouldHandle(event)) return;
            endDrag(event.pointerId);
          });
          doc.addEventListener('pointercancel', (event) => {
            if (!pointerShouldHandle(event)) return;
            endDrag(event.pointerId);
          });
        } catch (error) {
          // ignore frames blocked by policies
        }
      };

      track.addEventListener('touchstart', (event) => {
        if (event.touches.length !== 1) return;
        const touch = event.touches[0];
        startDrag(touch.clientX, touch.clientY);
      }, { passive: true });

      track.addEventListener('touchmove', (event) => {
        if (event.touches.length !== 1) return;
        const touch = event.touches[0];
        moveDrag(touch.clientX, touch.clientY);
      }, { passive: true });

      track.addEventListener('touchend', () => endDrag());
      track.addEventListener('touchcancel', () => endDrag());

      track.addEventListener('pointerdown', (event) => {
        if (!pointerShouldHandle(event) || event.button !== 0) return;
        startDrag(event.clientX, event.clientY, event.pointerId, true);
        if (track.setPointerCapture) {
          try {
            track.setPointerCapture(event.pointerId);
          } catch (error) {
            // ignore capture errors
          }
        }
        event.preventDefault();
      });

      track.addEventListener('pointermove', (event) => {
        if (!pointerShouldHandle(event)) return;
        if (!dragState.active) return;
        event.preventDefault();
        moveDrag(event.clientX, event.clientY, event.pointerId);
      });

      const releasePointer = (event) => {
        if (!pointerShouldHandle(event)) return;
        if (event.type === 'pointerleave' && track.hasPointerCapture && track.hasPointerCapture(event.pointerId)) {
          return;
        }
        if (track.releasePointerCapture) {
          try {
            track.releasePointerCapture(event.pointerId);
          } catch (error) {
            // ignore capture errors
          }
        }
        endDrag(event.pointerId);
      };

      track.addEventListener('pointerup', releasePointer);
      track.addEventListener('pointercancel', releasePointer);
      track.addEventListener('pointerleave', releasePointer);

      window.addEventListener('resize', () => snapToIndex(true));

      const initDockNav = (controller) => {
        const dock = document.getElementById('catalog-dock');
        if (!dock) return;
        dock.addEventListener('click', (event) => {
          const link = event.target.closest('.catalog-dock__link');
          if (!link) return;
          const href = link.dataset.target || link.getAttribute('href');
          if (goToHref(href)) {
            event.preventDefault();
          }
        });
        controller?.setActiveByHref(panels[currentIndex]?.dataset.src);
      };

      document.addEventListener('catalogNavReady', (event) => {
        navController = event.detail;
        initDockNav(navController);
      }, { once: true });

      if (window.catalogNavController) {
        navController = window.catalogNavController;
        initDockNav(navController);
      }

      const initHeaderNav = () => {
        const links = Array.from(document.querySelectorAll('.nav-link'));
        if (!links.length) {
          setTimeout(initHeaderNav, 80);
          return;
        }
        headerLinks = links;
        links.forEach(link => {
          const idx = findIndexByHref(link.getAttribute('href'));
          if (idx >= 0) {
            link.addEventListener('click', (event) => {
              event.preventDefault();
              updateActive(idx);
            });
          }
        });
        syncHeaderLinks(panels[currentIndex]?.dataset.src);
      };
      initHeaderNav();

      updateActive(0);
    });
  </script>
  <script src="js/scripts.js"></script>
  <script src="js/include.js"></script>
</body>
</html>
